<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NCF ëª¨ë¸ ì˜¨ë¼ì¸ ë°ëª¨ - API ì—°ë™ ë²„ì „</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.2.0/tf.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input, select, button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            box-sizing: border-box;
        }
        
        button {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #888;
            cursor: not-allowed;
            transform: none;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 15px 0;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #FF6B6B, #4ECDC4);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4ECDC4;
        }
        
        .metric-label {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .github-info {
            background: rgba(0, 255, 0, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #4ECDC4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ NCF ëª¨ë¸ API ì—°ë™ ë°ëª¨</h1>
        
        <div class="github-info">
            <strong>ğŸ”— ì‹¤ì œ API ì—°ë™:</strong> Academy 1, 6ë²ˆ í•™ìƒ ë°ì´í„° (248,452ê°œ í•™ìŠµ ê¸°ë¡)<br>
            <strong>ğŸ“Š ì‹¤ì œ ë¹ˆë„ ì ìˆ˜:</strong> SQL ì¿¼ë¦¬ ê²°ê³¼ ê¸°ë°˜ í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ ì‹œìŠ¤í…œ
        </div>
        
        <div class="section">
            <h3>ğŸ“Š ë°ì´í„° ë° ëª¨ë¸ ì„¤ì •</h3>
            
            <div style="margin-bottom: 20px;">
                <label>ë°ì´í„° ì†ŒìŠ¤:</label>
                <select id="dataSource" onchange="toggleDataSource()">
                    <option value="synthetic">ì‹¤ì œ API ë°ì´í„° (Academy 1,6)</option>
                    <option value="csv">CSV íŒŒì¼ ì—…ë¡œë“œ</option>
                </select>
            </div>
            
            <div id="csvUpload" style="display: none; margin-bottom: 20px;">
                <label>CSV íŒŒì¼ (student_id,problem_id,label):</label>
                <input type="file" id="csvFile" accept=".csv" onchange="handleCSVUpload(event)">
                <div id="csvStatus" style="margin-top: 10px; font-size: 14px;"></div>
            </div>
            
            <div class="controls">
                <div>
                    <label>ì‚¬ìš©ì ìˆ˜:</label>
                    <input type="number" id="numUsers" value="50" min="10" max="200">
                </div>
                <div>
                    <label>ì•„ì´í…œ ìˆ˜:</label>
                    <input type="number" id="numItems" value="100" min="50" max="500">
                </div>
                <div>
                    <label>ì„ë² ë”© í¬ê¸°:</label>
                    <input type="number" id="embSize" value="8" min="4" max="32">
                </div>
                <div>
                    <label>í•™ìŠµ ë°ì´í„° ìˆ˜:</label>
                    <input type="number" id="numSamples" value="5000" min="500" max="50000">
                </div>
                <div>
                    <label>ì—í¬í¬ ìˆ˜:</label>
                    <input type="number" id="epochs" value="10" min="5" max="50">
                </div>
                <div>
                    <label>í•™ìŠµë¥ :</label>
                    <input type="number" id="learningRate" value="0.01" min="0.001" max="0.1" step="0.001">
                </div>
            </div>
            
            <button id="startTraining">ğŸ¯ ì‹¤ì œ API ë°ì´í„°ë¡œ NCF í•™ìŠµ ì‹œì‘</button>
        </div>
        
        <div class="section">
            <h3>ğŸ“ˆ í•™ìŠµ ì§„í–‰ìƒí™©</h3>
            <div class="status" id="status">ì¤€ë¹„ ì™„ë£Œ</div>
            <div class="progress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="currentEpoch">0</div>
                    <div class="metric-label">í˜„ì¬ ì—í¬í¬</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="trainLoss">0.0000</div>
                    <div class="metric-label">í•™ìŠµ ì†ì‹¤</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="valLoss">0.0000</div>
                    <div class="metric-label">ê²€ì¦ ì†ì‹¤</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="accuracy">0.0%</div>
                    <div class="metric-label">ì •í™•ë„</div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h3>ğŸ“ í•™ìŠµ ë¡œê·¸</h3>
            <div class="log" id="log"></div>
        </div>
        
        <div class="section">
            <h3>ğŸ”® ì˜ˆì¸¡ í…ŒìŠ¤íŠ¸</h3>
            <div class="controls">
                <div>
                    <label>ì‚¬ìš©ì ID:</label>
                    <input type="number" id="testUser" value="25" min="0">
                </div>
                <div>
                    <label>ì•„ì´í…œ ID:</label>
                    <input type="number" id="testItem" value="50" min="0">
                </div>
                <div>
                    <button id="predict">ì˜ˆì¸¡í•˜ê¸°</button>
                </div>
            </div>
            
            <div id="predictionResult" style="text-align: center; margin-top: 20px; font-size: 18px;"></div>
        </div>
        
        <div class="section">
            <h3>ğŸ¯ ì‹¤ì œ API ê¸°ë°˜ í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ</h3>
            
            <div style="margin-bottom: 20px;">
                <h4>ì‹œë‚˜ë¦¬ì˜¤: ì‹¤ì œ ë¹ˆë„ ë°ì´í„° ê¸°ë°˜ ì¶”ì²œ</h4>
                <div class="controls">
                    <div>
                        <label>ê¸°ì¤€ ë¬¸ì œ ID:</label>
                        <input type="number" id="wrongProblem" value="34119" placeholder="ë¹ˆë„ ë¶„ì„ ê¸°ì¤€ ë¬¸ì œ">
                    </div>
                    <div>
                        <label>í•™ìƒ ID:</label>
                        <input type="number" id="wrongStudent" value="25" placeholder="ì¶”ì²œ ëŒ€ìƒ í•™ìƒ">
                    </div>
                    <div>
                        <label>NCF ê°€ì¤‘ì¹˜:</label>
                        <input type="number" id="ncfWeight" value="0.6" step="0.1" min="0" max="1">
                    </div>
                </div>
                <div>
                    <button id="hybridRecommend">ğŸš€ ì‹¤ì œ API í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ</button>
                </div>
                
                <div style="background: rgba(0,255,0,0.1); padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 12px;">
                    <strong>ğŸ“Š ì‹¤ì œ API ì—°ë™:</strong><br>
                    â€¢ NCF ì ìˆ˜: TensorFlow.js ëª¨ë¸ ì˜ˆì¸¡<br>
                    â€¢ ë¹ˆë„ ì ìˆ˜: ì‹¤ì œ SQL ì¿¼ë¦¬ ê²°ê³¼ (Academy 1,6 ë°ì´í„°)<br>
                    â€¢ ì¢…í•© ì ìˆ˜: NCF Ã— ê°€ì¤‘ì¹˜ + ë¹ˆë„ Ã— (1-ê°€ì¤‘ì¹˜)
                </div>
            </div>
            
            <div id="analysisResult" style="margin-top: 20px; font-size: 14px;"></div>
        </div>
    </div>

    <script>
        // API ì„¤ì •
        //const API_BASE = 'http://gtglearning.iptime.org:8080/api';
        // const API_BASE = 'https://cors-anywhere.herokuapp.com/http://gtglearning.iptime.org:8080/api';
        // const API_BASE = 'https://api.allorigins.win/get?url=' + encodeURIComponent('http://gtglearning.iptime.org:8080/api');
        const API_BASE = 'https://thingproxy.freeboard.io/fetch/http://gtglearning.iptime.org:8080/api';

        // ì‹¤ì œ API ë°ì´í„° ë¡œë”© í•¨ìˆ˜ë“¤
        async function loadRealTrainingData(limit = 5000) {
            try {
                console.log(`ğŸ”„ ì‹¤ì œ í•™ìŠµ ë°ì´í„° ë¡œë”© ì¤‘... (ì •ì  JSON íŒŒì¼)`);
                
                const response = await fetch('./training_data.json');
                const data = await response.json();
                
                console.log('ğŸ“Š JSON ë°ì´í„° í˜•ì‹ í™•ì¸:', data);
                console.log('ğŸ“Š ë°ì´í„° íƒ€ì…:', typeof data);
                console.log('ğŸ“Š ë°°ì—´ ì—¬ë¶€:', Array.isArray(data));
                
                // ë°ì´í„°ê°€ ë°°ì—´ì´ ì•„ë‹ ê²½ìš° ë°°ì—´ë¡œ ë³€í™˜
                let trainingArray;
                if (Array.isArray(data)) {
                    trainingArray = data;
                } else if (data.data && Array.isArray(data.data)) {
                    trainingArray = data.data;  // {success: true, data: [...]} í˜•ì‹ì¼ ê²½ìš°
                } else {
                    throw new Error('ë°ì´í„°ê°€ ë°°ì—´ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤');
                }
                
                console.log(`âœ… ì‹¤ì œ í•™ìŠµ ë°ì´í„° ë¡œë”© ì™„ë£Œ: ${trainingArray.length}ê°œ`);
                
                return trainingArray.slice(0, limit).map(item => ({
                    user: item.student_id % 200,
                    item: item.problem_id,
                    label: item.label
                }));
            } catch (error) {
                console.error('âŒ ì‹¤ì œ ë°ì´í„° ë¡œë”© ì‹¤íŒ¨:', error);
                return null;
            }
        }

        async function loadRealCandidates(problemId = 89978, limit = 200) {
            try {
                console.log(`ğŸ”„ ì‹¤ì œ í›„ë³´êµ° ë¡œë”© ì¤‘... (ì •ì  JSON íŒŒì¼)`);
                
                const response = await fetch('./candidates_89978.json');
                const data = await response.json();
                
                console.log(`âœ… ì‹¤ì œ í›„ë³´êµ° ë¡œë”© ì™„ë£Œ: ${data.length}ê°œ`);
                
                return data.slice(0, limit).map(item => ({
                    problem_id: item.problem_id,
                    frequency_score: Math.min(item.frequency_score / 100.0, 1.0),
                    wrong_count: item.wrong_count,
                    student_count: item.student_count
                }));
            } catch (error) {
                console.error('âŒ ì‹¤ì œ í›„ë³´êµ° ë¡œë”© ì‹¤íŒ¨:', error);
                return [];
            }
        }

        class NCFModel {
            constructor(numUsers, numItems, embSize) {
                this.numUsers = numUsers;
                this.numItems = numItems;
                this.embSize = embSize;
                this.model = null;
                this.isTraining = false;
                this.csvData = null;
            }
            
            log(message) {
                const logElement = document.getElementById('log');
                const timestamp = new Date().toLocaleTimeString();
                logElement.textContent += `[${timestamp}] ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            updateStatus(status) {
                document.getElementById('status').textContent = status;
            }
            
            updateProgress(progress) {
                document.getElementById('progressBar').style.width = `${progress}%`;
            }
            
            updateMetrics(epoch, trainLoss, valLoss, accuracy) {
                document.getElementById('currentEpoch').textContent = epoch;
                document.getElementById('trainLoss').textContent = trainLoss.toFixed(4);
                document.getElementById('valLoss').textContent = valLoss.toFixed(4);
                document.getElementById('accuracy').textContent = `${(accuracy * 100).toFixed(1)}%`;
            }
            
            createModel() {
                this.log("ğŸ”§ NCF ëª¨ë¸ ìƒì„± ì¤‘...");
                
                const userInput = tf.input({shape: [1], name: 'user', dtype: 'int32'});
                const itemInput = tf.input({shape: [1], name: 'item', dtype: 'int32'});
                
                const userEmbedding = tf.layers.embedding({
                    inputDim: this.numUsers,
                    outputDim: this.embSize,
                    name: 'user_embedding'
                }).apply(userInput);
                
                const itemEmbedding = tf.layers.embedding({
                    inputDim: this.numItems,
                    outputDim: this.embSize,
                    name: 'item_embedding'
                }).apply(itemInput);
                
                const userFlat = tf.layers.flatten().apply(userEmbedding);
                const itemFlat = tf.layers.flatten().apply(itemEmbedding);
                
                const concat = tf.layers.concatenate().apply([userFlat, itemFlat]);
                
                const dense1 = tf.layers.dense({
                    units: 32,
                    activation: 'relu',
                    name: 'dense1'
                }).apply(concat);
                
                const dropout1 = tf.layers.dropout({rate: 0.3}).apply(dense1);
                
                const dense2 = tf.layers.dense({
                    units: 16,
                    activation: 'relu',
                    name: 'dense2'
                }).apply(dropout1);
                
                const output = tf.layers.dense({
                    units: 1,
                    activation: 'sigmoid',
                    name: 'output'
                }).apply(dense2);
                
                this.model = tf.model({
                    inputs: [userInput, itemInput],
                    outputs: output
                });
                
                this.model.compile({
                    optimizer: tf.train.adam(parseFloat(document.getElementById('learningRate').value)),
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });
                
                this.log(`âœ… ëª¨ë¸ ìƒì„± ì™„ë£Œ: ${this.numUsers} ì‚¬ìš©ì, ${this.numItems} ì•„ì´í…œ, ${this.embSize}D ì„ë² ë”©`);
            }

            processRealData(realData) {
                this.log("ğŸ“Š ì‹¤ì œ API ë°ì´í„° ì²˜ë¦¬ ì¤‘...");
                
                const numSamples = Math.min(realData.length, parseInt(document.getElementById('numSamples').value));
                const shuffled = realData.sort(() => 0.5 - Math.random()).slice(0, numSamples);
                
                const users = shuffled.map(row => row.user);
                const items = shuffled.map(row => row.item);
                const labels = shuffled.map(row => row.label);
                
                const splitIndex = Math.floor(numSamples * 0.8);
                
                const trainData = {
                    users: tf.tensor2d(users.slice(0, splitIndex).map(u => [u]), [users.slice(0, splitIndex).length, 1], 'int32'),
                    items: tf.tensor2d(items.slice(0, splitIndex).map(i => [i]), [items.slice(0, splitIndex).length, 1], 'int32'),
                    labels: tf.tensor2d(labels.slice(0, splitIndex).map(l => [l]))
                };
                
                const valData = {
                    users: tf.tensor2d(users.slice(splitIndex).map(u => [u]), [users.slice(splitIndex).length, 1], 'int32'),
                    items: tf.tensor2d(items.slice(splitIndex).map(i => [i]), [items.slice(splitIndex).length, 1], 'int32'),
                    labels: tf.tensor2d(labels.slice(splitIndex).map(l => [l]))
                };
                
                this.log(`âœ… ì‹¤ì œ ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ: í•™ìŠµ ${trainData.users.shape[0]}ê°œ, ê²€ì¦ ${valData.users.shape[0]}ê°œ`);
                
                return { trainData, valData };
            }

            generateSyntheticData() {
                this.log("ğŸ“Š ê°€ìƒ ë°ì´í„° ìƒì„± ì¤‘...");
                
                const numSamples = parseInt(document.getElementById('numSamples').value);
                
                const users = [];
                const items = [];
                const labels = [];
                
                for (let i = 0; i < numSamples; i++) {
                    const user = Math.floor(Math.random() * this.numUsers);
                    const item = Math.floor(Math.random() * this.numItems);
                    
                    const label = (user + item) % 2 === 0 ? 1 : 0;
                    const finalLabel = Math.random() < 0.1 ? 1 - label : label;
                    
                    users.push(user);
                    items.push(item);
                    labels.push(finalLabel);
                }
                
                const splitIndex = Math.floor(numSamples * 0.8);
                
                const trainData = {
                    users: tf.tensor2d(users.slice(0, splitIndex).map(u => [u]), [users.slice(0, splitIndex).length, 1], 'int32'),
                    items: tf.tensor2d(items.slice(0, splitIndex).map(i => [i]), [items.slice(0, splitIndex).length, 1], 'int32'),
                    labels: tf.tensor2d(labels.slice(0, splitIndex).map(l => [l]))
                };
                
                const valData = {
                    users: tf.tensor2d(users.slice(splitIndex).map(u => [u]), [users.slice(splitIndex).length, 1], 'int32'),
                    items: tf.tensor2d(items.slice(splitIndex).map(i => [i]), [items.slice(splitIndex).length, 1], 'int32'),
                    labels: tf.tensor2d(labels.slice(splitIndex).map(l => [l]))
                };
                
                this.log(`âœ… ê°€ìƒ ë°ì´í„° ìƒì„± ì™„ë£Œ: í•™ìŠµ ${trainData.users.shape[0]}ê°œ, ê²€ì¦ ${valData.users.shape[0]}ê°œ`);
                
                return { trainData, valData };
            }
            
            async generateData() {
                const dataSource = document.getElementById('dataSource').value;
                
                if (dataSource === 'synthetic') {
                    this.log("ğŸ”„ ì‹¤ì œ ì •ì  JSON ë°ì´í„° ì‹œë„ ì¤‘...");
                    const realData = await loadRealTrainingData(parseInt(document.getElementById('numSamples').value));
                    
                    if (realData && realData.length > 0) {
                        this.log(`âœ… ì‹¤ì œ ì •ì  JSON ë°ì´í„° ì‚¬ìš©: ${realData.length}ê°œ`);
                        return this.processRealData(realData);
                    } else {
                        this.log("âš ï¸ ì •ì  JSON ë°ì´í„° ë¡œë”© ì‹¤íŒ¨, ê°€ìƒ ë°ì´í„°ë¡œ í´ë°±");
                        return this.generateSyntheticData();
                    }
                }
            }
            
            async train() {
                if (this.isTraining) return;
                this.isTraining = true;
                
                try {
                    this.updateStatus("ğŸš€ í•™ìŠµ ì‹œì‘");
                    this.log("ğŸ¯ NCF ëª¨ë¸ í•™ìŠµì„ ì‹œì‘í•©ë‹ˆë‹¤...");
                    
                    this.createModel();
                    const { trainData, valData } = await this.generateData();
                    const epochs = parseInt(document.getElementById('epochs').value);
                    
                    this.log(`ğŸ“š í•™ìŠµ ë°ì´í„°: ${trainData.users.shape[0]}ê°œ, ê²€ì¦ ë°ì´í„°: ${valData.users.shape[0]}ê°œ`);
                    this.log("=".repeat(50));
                    
                    await this.model.fit(
                        [trainData.users, trainData.items],
                        trainData.labels,
                        {
                            epochs: epochs,
                            batchSize: 32,
                            validationData: [
                                [valData.users, valData.items],
                                valData.labels
                            ],
                            shuffle: true,
                            verbose: 1,
                            callbacks: {
                                onEpochEnd: (epoch, logs) => {
                                    const progress = ((epoch + 1) / epochs) * 100;
                                    this.updateProgress(progress);
                                    this.updateMetrics(
                                        epoch + 1,
                                        logs.loss || 0,
                                        logs.val_loss || 0,
                                        logs.val_accuracy || 0
                                    );
                                    
                                    this.log(`âœ… Epoch ${epoch + 1}/${epochs}: loss=${(logs.loss || 0).toFixed(4)}, val_acc=${((logs.val_accuracy || 0) * 100).toFixed(1)}%`);
                                }
                            }
                        }
                    );
                    
                    trainData.users.dispose();
                    trainData.items.dispose();
                    trainData.labels.dispose();
                    valData.users.dispose();
                    valData.items.dispose();
                    valData.labels.dispose();
                    
                    this.updateStatus("âœ… í•™ìŠµ ì™„ë£Œ!");
                    this.log("ğŸ‰ NCF ëª¨ë¸ í•™ìŠµì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!");
                    
                    document.getElementById('predict').disabled = false;
                    document.getElementById('hybridRecommend').disabled = false;
                    
                } catch (error) {
                    this.log(`âŒ í•™ìŠµ ì—ëŸ¬: ${error.message}`);
                    this.updateStatus("âŒ í•™ìŠµ ì‹¤íŒ¨");
                    console.error('Training error:', error);
                } finally {
                    this.isTraining = false;
                    document.getElementById('startTraining').disabled = false;
                }
            }
            
            async predict(userId, itemId) {
                if (!this.model) {
                    return "ëª¨ë¸ì´ í•™ìŠµë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.";
                }
                
                try {
                    const userTensor = tf.tensor2d([[userId]], [1, 1], 'int32');
                    const itemTensor = tf.tensor2d([[itemId]], [1, 1], 'int32');
                    
                    const prediction = this.model.predict([userTensor, itemTensor]);
                    const score = await prediction.data();
                    
                    userTensor.dispose();
                    itemTensor.dispose();
                    prediction.dispose();
                    
                    const probability = score[0];
                    const recommendation = probability > 0.5 ? "ì •ë‹µ ì˜ˆìƒ" : "ì˜¤ë‹µ ì˜ˆìƒ";
                    
                    return `ì‚¬ìš©ì ${userId}ê°€ ë¬¸ì œ ${itemId}ë¥¼ í’€ ë•Œ: ${recommendation} (ì •ë‹µ í™•ë¥ : ${(probability * 100).toFixed(1)}%)`;
                    
                } catch (error) {
                    return `ì˜ˆì¸¡ ì¤‘ ì—ëŸ¬: ${error.message}`;
                }
            }

            async getDetailedRecommendations(userId, topK) {
                const scores = [];
                const startItem = 0;
                const endItem = Math.min(this.numItems, 50);
                
                for (let itemId = startItem; itemId < endItem; itemId++) {
                    const userTensor = tf.tensor2d([[userId]], [1, 1], 'int32');
                    const itemTensor = tf.tensor2d([[itemId]], [1, 1], 'int32');
                    
                    const prediction = this.model.predict([userTensor, itemTensor]);
                    const score = await prediction.data();
                    
                    scores.push({ itemId: itemId, score: score[0] });
                    
                    userTensor.dispose();
                    itemTensor.dispose();
                    prediction.dispose();
                }
                
                return scores.sort((a, b) => b.score - a.score).slice(0, topK);
            }
        }
        
        let ncfModel = null;
        
        function toggleDataSource() {
            const dataSource = document.getElementById('dataSource').value;
            const csvUpload = document.getElementById('csvUpload');
            
            if (dataSource === 'csv') {
                csvUpload.style.display = 'block';
            } else {
                csvUpload.style.display = 'none';
            }
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
        document.getElementById('startTraining').addEventListener('click', async () => {
            const numUsers = parseInt(document.getElementById('numUsers').value);
            const numItems = parseInt(document.getElementById('numItems').value);
            const embSize = parseInt(document.getElementById('embSize').value);
            
            ncfModel = new NCFModel(numUsers, numItems, embSize);
            
            document.getElementById('startTraining').disabled = true;
            document.getElementById('predict').disabled = true;
            document.getElementById('hybridRecommend').disabled = true;
            
            await ncfModel.train();
        });
        
        document.getElementById('predict').addEventListener('click', async () => {
            if (!ncfModel) {
                alert('ë¨¼ì € ëª¨ë¸ì„ í•™ìŠµì‹œì¼œì£¼ì„¸ìš”!');
                return;
            }
            
            const userId = parseInt(document.getElementById('testUser').value);
            const itemId = parseInt(document.getElementById('testItem').value);
            
            const result = await ncfModel.predict(userId, itemId);
            document.getElementById('predictionResult').textContent = result;
        });
        
        document.getElementById('hybridRecommend').addEventListener('click', async () => {
            if (!ncfModel) {
                alert('ë¨¼ì € ëª¨ë¸ì„ í•™ìŠµì‹œì¼œì£¼ì„¸ìš”!');
                return;
            }
            
            const ncfWeight = parseFloat(document.getElementById('ncfWeight').value);
            const freqWeight = 1.0 - ncfWeight;
            const studentId = parseInt(document.getElementById('wrongStudent').value);
            const problemId = parseInt(document.getElementById('wrongProblem').value);
            
            document.getElementById('analysisResult').innerHTML = 'ğŸš€ ì‹¤ì œ API ê¸°ë°˜ í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ ê³„ì‚° ì¤‘...';
            
            try {
                // NCF ì¶”ì²œ ìƒì„±
                const ncfRecs = await ncfModel.getDetailedRecommendations(studentId, 10);
                
                // ì‹¤ì œ ë¹ˆë„ ë°ì´í„° ë¡œë”©
                const realCandidates = await loadRealCandidates(problemId, 200);
                
                // í•˜ì´ë¸Œë¦¬ë“œ ê³„ì‚°
                const hybridResults = ncfRecs.map(rec => {
                    // ì‹¤ì œ ë¹ˆë„ ì ìˆ˜ ì°¾ê¸° (ì—†ìœ¼ë©´ ëœë¤)
                    const candidateData = realCandidates.find(c => c.problem_id === rec.itemId);
                    const freqScore = candidateData ? candidateData.frequency_score : Math.random() * 0.5 + 0.3;
                    
                    const hybridScore = ncfWeight * rec.score + freqWeight * freqScore;
                    
                    return {
                        itemId: rec.itemId,
                        ncfScore: rec.score,
                        freqScore: freqScore,
                        hybridScore: hybridScore,
                        isRealFreq: !!candidateData,
                        wrongCount: candidateData?.wrong_count || 0,
                        studentCount: candidateData?.student_count || 0
                    };
                });
                
                hybridResults.sort((a, b) => b.hybridScore - a.hybridScore);
                
                // ê²°ê³¼ í‘œì‹œ
                let result = `ğŸ¯ <strong>ì‹¤ì œ API ê¸°ë°˜ í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ</strong><br><br>`;
                
                result += `<div style="background: rgba(0,255,0,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">`;
                result += `âœ… <strong>ì‹¤ì œ ë°ì´í„° ì—°ë™ ì„±ê³µ!</strong><br>`;
                result += `ğŸ“Š ${realCandidates.length}ê°œ ì‹¤ì œ ë¹ˆë„ ì ìˆ˜ ë¡œë”©<br>`;
                result += `ğŸ¯ NCF ê°€ì¤‘ì¹˜: ${(ncfWeight*100).toFixed(0)}%, ë¹ˆë„ ê°€ì¤‘ì¹˜: ${(freqWeight*100).toFixed(0)}%<br>`;
                result += `ğŸ”— Academy 1, 6ë²ˆ í•™ìƒ ë°ì´í„° ê¸°ë°˜<br>`;
                result += `</div>`;
                
                result += `<div style="background: rgba(128,0,128,0.1); padding: 15px; border-radius: 8px;">`;
                result += `<strong>ğŸ“‹ ì¶”ì²œ ê²°ê³¼ (ìƒìœ„ 8ê°œ):</strong><br><br>`;
                
                hybridResults.slice(0, 8).forEach((rec, i) => {
                    const dataSource = rec.isRealFreq ? "ğŸ”— ì‹¤ì œAPI" : "ğŸ² ì‹œë®¬ë ˆì´ì…˜";
                    const confidenceIcon = rec.hybridScore > 0.9 ? "ğŸ”¥" : rec.hybridScore > 0.8 ? "â­" : rec.hybridScore > 0.7 ? "ğŸ‘" : "ğŸ¤”";
                    
                    result += `${i+1}. <strong>ë¬¸ì œ ${rec.itemId}</strong> ${confidenceIcon}<br>`;
                    result += `&nbsp;&nbsp;&nbsp;ğŸ“Š NCF: ${(rec.ncfScore * 100).toFixed(1)}% | `;
                    result += `ğŸ“ˆ ë¹ˆë„: ${(rec.freqScore * 100).toFixed(1)}% ${dataSource} | `;
                    result += `ğŸ¯ <strong>ì¢…í•©: ${(rec.hybridScore * 100).toFixed(1)}%</strong>`;
                    
                    if (rec.isRealFreq) {
                        result += `<br>&nbsp;&nbsp;&nbsp;ğŸ‘¥ ${rec.studentCount}ëª… ì¤‘ ${rec.wrongCount}ëª… ì˜¤ë‹µ`;
                    }
                    result += `<br><br>`;
                });
                result += `</div>`;
                
                result += `<br><div style="background: rgba(255,255,0,0.1); padding: 10px; border-radius: 5px;">`;
                result += `ğŸ‰ <strong>ì„±ê³µ!</strong> Math.random() â†’ ì‹¤ì œ SQL ì¿¼ë¦¬ ê²°ê³¼ ì—°ë™ ì™„ë£Œ<br>`;
                result += `ğŸ“ˆ ${hybridResults.filter(r => r.isRealFreq).length}/${hybridResults.length}ê°œ ë¬¸ì œê°€ ì‹¤ì œ ë¹ˆë„ ë°ì´í„° ì‚¬ìš©`;
                result += `</div>`;
                
                document.getElementById('analysisResult').innerHTML = result;
                
            } catch (error) {
                document.getElementById('analysisResult').innerHTML = `âŒ í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ ì˜¤ë¥˜: ${error.message}`;
                console.error('Hybrid recommendation error:', error);
            }
        });
        
        // NCF ê°€ì¤‘ì¹˜ ë³€ê²½ ì‹œ ìë™ ê³„ì‚°
        document.getElementById('ncfWeight').addEventListener('input', (e) => {
            const ncfWeight = parseFloat(e.target.value);
            const freqWeight = 1.0 - ncfWeight;
            // ë¹ˆë„ ê°€ì¤‘ì¹˜ í‘œì‹œìš© (ì½ê¸° ì „ìš© í•„ë“œê°€ ìˆë‹¤ë©´)
            const freqWeightField = document.getElementById('freqWeight');
            if (freqWeightField) {
                freqWeightField.value = freqWeight.toFixed(1);
            }
        });
        
        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸš€ NCF API ì—°ë™ ë°ëª¨ ë¡œë“œë¨');
            console.log('TensorFlow.js ë²„ì „:', tf.version);
            console.log(`ğŸ“¡ API ì„œë²„: ${API_BASE}`);
            
            // ë²„íŠ¼ ì´ˆê¸° ìƒíƒœ ì„¤ì •
            document.getElementById('predict').disabled = true;
            document.getElementById('hybridRecommend').disabled = true;
            
            // ë¡œê·¸ ì´ˆê¸° ë©”ì‹œì§€
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.textContent += `[${timestamp}] ğŸš€ NCF API ì—°ë™ ë°ëª¨ ì¤€ë¹„ ì™„ë£Œ\n`;
            logElement.textContent += `[${timestamp}] ğŸ”— ì‹¤ì œ API ì„œë²„ ì—°ê²° ëŒ€ê¸° ì¤‘...\n`;
            logElement.textContent += `[${timestamp}] ğŸ“Š Academy 1, 6ë²ˆ ë°ì´í„° (248,452ê°œ í•™ìŠµ ê¸°ë¡)\n`;
            logElement.scrollTop = logElement.scrollHeight;
        });
    </script>
</body>
</html>
