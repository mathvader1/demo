<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NCF ëª¨ë¸ ì˜¨ë¼ì¸ ë°ëª¨ - GitHub Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.2.0/tf.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input, select, button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            box-sizing: border-box;
        }
        
        button {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #888;
            cursor: not-allowed;
            transform: none;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 15px 0;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #FF6B6B, #4ECDC4);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4ECDC4;
        }
        
        .metric-label {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .github-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #4ECDC4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ NCF ëª¨ë¸ ì˜¨ë¼ì¸ ë°ëª¨</h1>
        
        <div class="github-info">
            <strong>ğŸŒŸ GitHub Pagesë¡œ í˜¸ìŠ¤íŒ…ë¨!</strong><br>
            Neural Collaborative Filtering ëª¨ë¸ì„ ë¸Œë¼ìš°ì €ì—ì„œ ì§ì ‘ í•™ìŠµí•˜ê³  í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </div>
        
        <div class="section">
            <h3>ğŸ“Š ë°ì´í„° ë° ëª¨ë¸ ì„¤ì •</h3>
            
            <div style="margin-bottom: 20px;">
                <label>ë°ì´í„° ì†ŒìŠ¤:</label>
                <select id="dataSource" onchange="toggleDataSource()">
                    <option value="synthetic">ê°€ìƒ ë°ì´í„° ìƒì„±</option>
                    <option value="csv">CSV íŒŒì¼ ì—…ë¡œë“œ</option>
                </select>
            </div>
            
            <div id="csvUpload" style="display: none; margin-bottom: 20px;">
                <label>CSV íŒŒì¼ (student_id,problem_id,label):</label>
                <input type="file" id="csvFile" accept=".csv" onchange="handleCSVUpload(event)">
                <div id="csvStatus" style="margin-top: 10px; font-size: 14px;"></div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-top: 5px;">
                    ì˜ˆì‹œ: 255,12701,1 (ì‚¬ìš©ì255ê°€ ë¬¸ì œ12701ì„ ë§ì¶¤)
                </div>
            </div>
            
            <div class="controls">
                <div>
                    <label>ì‚¬ìš©ì ìˆ˜:</label>
                    <input type="number" id="numUsers" value="50" min="10" max="200">
                </div>
                <div>
                    <label>ì•„ì´í…œ ìˆ˜:</label>
                    <input type="number" id="numItems" value="100" min="50" max="500">
                </div>
                <div>
                    <label>ì„ë² ë”© í¬ê¸°:</label>
                    <input type="number" id="embSize" value="8" min="4" max="32">
                </div>
                <div>
                    <label>í•™ìŠµ ë°ì´í„° ìˆ˜:</label>
                    <input type="number" id="numSamples" value="1000" min="500" max="5000">
                </div>
                <div>
                    <label>ì—í¬í¬ ìˆ˜:</label>
                    <input type="number" id="epochs" value="10" min="5" max="50">
                </div>
                <div>
                    <label>í•™ìŠµë¥ :</label>
                    <input type="number" id="learningRate" value="0.01" min="0.001" max="0.1" step="0.001">
                </div>
            </div>
            
            <button id="startTraining">ğŸ¯ NCF ëª¨ë¸ í•™ìŠµ ì‹œì‘</button>
        </div>
        
        <div class="section">
            <h3>ğŸ“ˆ í•™ìŠµ ì§„í–‰ìƒí™©</h3>
            <div class="status" id="status">ì¤€ë¹„ ì™„ë£Œ</div>
            <div class="progress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="currentEpoch">0</div>
                    <div class="metric-label">í˜„ì¬ ì—í¬í¬</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="trainLoss">0.0000</div>
                    <div class="metric-label">í•™ìŠµ ì†ì‹¤</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="valLoss">0.0000</div>
                    <div class="metric-label">ê²€ì¦ ì†ì‹¤</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="accuracy">0.0%</div>
                    <div class="metric-label">ì •í™•ë„</div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h3>ğŸ“ í•™ìŠµ ë¡œê·¸</h3>
            <div class="log" id="log"></div>
        </div>
        
        <div class="section">
            <h3>ğŸ”® ì˜ˆì¸¡ í…ŒìŠ¤íŠ¸</h3>
            <div class="controls">
                <div>
                    <label>ì‚¬ìš©ì ID:</label>
                    <input type="number" id="testUser" value="255" min="0">
                </div>
                <div>
                    <label>ì•„ì´í…œ ID:</label>
                    <input type="number" id="testItem" value="12701" min="0">
                </div>
                <div>
                    <button id="predict">ì˜ˆì¸¡í•˜ê¸°</button>
                </div>
            </div>
            
            <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin: 10px 0;">
                ğŸ’¡ íŒ: ì‚¬ìš©ì 255ëŠ” ì‹¤ì œ CSV ë°ì´í„°ì˜ ê³ ëŠ¥ë ¥ í•™ìƒì…ë‹ˆë‹¤
            </div>
            
            <div id="predictionResult" style="text-align: center; margin-top: 20px; font-size: 18px;"></div>
        </div>
        
        <div class="section">
            <h3>ğŸ¯ ì‹¤ì „ ì¶”ì²œ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸</h3>
            
            <div style="margin-bottom: 20px;">
                <h4>ì‹œë‚˜ë¦¬ì˜¤ 1: í‹€ë¦° ë¬¸ì œ ê¸°ë°˜ ì¶”ì²œ</h4>
                <div class="controls">
                    <div>
                        <label>í‹€ë¦° ë¬¸ì œ ID:</label>
                        <input type="number" id="wrongProblem" value="34119" placeholder="í•™ìƒì´ í‹€ë¦° ë¬¸ì œ">
                    </div>
                    <div>
                        <label>í•´ë‹¹ í•™ìƒ ID:</label>
                        <input type="number" id="wrongStudent" value="255" placeholder="ë¬¸ì œë¥¼ í‹€ë¦° í•™ìƒ">
                    </div>
                    <div>
                        <button id="analyzeWrongProblem">ğŸ” ë¶„ì„ ì‹œì‘</button>
                    </div>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h4>ì‹œë‚˜ë¦¬ì˜¤ 2: í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ</h4>
                <div class="controls">
                    <div>
                        <label>NCF ê°€ì¤‘ì¹˜ (0.0-1.0):</label>
                        <input type="number" id="ncfWeight" value="0.6" step="0.1" min="0" max="1">
                    </div>
                    <div>
                        <label>ë¹ˆë„ ê°€ì¤‘ì¹˜ (ìë™ê³„ì‚°):</label>
                        <input type="number" id="freqWeight" value="0.4" step="0.1" min="0" max="1" readonly>
                    </div>
                    <div>
                        <button id="hybridRecommend">ğŸš€ í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ</button>
                    </div>
                </div>
            </div>
            
            <div id="analysisResult" style="margin-top: 20px; font-size: 14px;"></div>
        </div>
    </div>

    <script>
        class NCFModel {
            constructor(numUsers, numItems, embSize) {
                this.numUsers = numUsers;
                this.numItems = numItems;
                this.embSize = embSize;
                this.model = null;
                this.isTraining = false;
                this.csvData = null;
            }
            
            log(message) {
                const logElement = document.getElementById('log');
                const timestamp = new Date().toLocaleTimeString();
                logElement.textContent += `[${timestamp}] ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            updateStatus(status) {
                document.getElementById('status').textContent = status;
            }
            
            updateProgress(progress) {
                document.getElementById('progressBar').style.width = `${progress}%`;
            }
            
            updateMetrics(epoch, trainLoss, valLoss, accuracy) {
                document.getElementById('currentEpoch').textContent = epoch;
                document.getElementById('trainLoss').textContent = trainLoss.toFixed(4);
                document.getElementById('valLoss').textContent = valLoss.toFixed(4);
                document.getElementById('accuracy').textContent = `${(accuracy * 100).toFixed(1)}%`;
            }
            
            createModel() {
                this.log("ğŸ”§ NCF ëª¨ë¸ ìƒì„± ì¤‘...");
                
                // ì…ë ¥ì„ 1D í˜•íƒœë¡œ ì •ì˜ (TensorFlow.js ì„ë² ë”© í˜¸í™˜)
                const userInput = tf.input({shape: [1], name: 'user', dtype: 'int32'});
                const itemInput = tf.input({shape: [1], name: 'item', dtype: 'int32'});
                
                // ì„ë² ë”© ë ˆì´ì–´ - inputLength ì œê±°í•˜ê³  reshape ì‚¬ìš©
                const userEmbedding = tf.layers.embedding({
                    inputDim: this.numUsers,
                    outputDim: this.embSize,
                    name: 'user_embedding'
                }).apply(userInput);
                
                const itemEmbedding = tf.layers.embedding({
                    inputDim: this.numItems,
                    outputDim: this.embSize,
                    name: 'item_embedding'
                }).apply(itemInput);
                
                // ì„ë² ë”© í‰íƒ„í™” (3D -> 2D)
                const userFlat = tf.layers.flatten().apply(userEmbedding);
                const itemFlat = tf.layers.flatten().apply(itemEmbedding);
                
                // ì—°ê²°
                const concat = tf.layers.concatenate().apply([userFlat, itemFlat]);
                
                // ë°€ì§‘ ë ˆì´ì–´ë“¤
                const dense1 = tf.layers.dense({
                    units: 32,
                    activation: 'relu',
                    name: 'dense1'
                }).apply(concat);
                
                const dropout1 = tf.layers.dropout({rate: 0.3}).apply(dense1);
                
                const dense2 = tf.layers.dense({
                    units: 16,
                    activation: 'relu',
                    name: 'dense2'
                }).apply(dropout1);
                
                const output = tf.layers.dense({
                    units: 1,
                    activation: 'sigmoid',
                    name: 'output'
                }).apply(dense2);
                
                this.model = tf.model({
                    inputs: [userInput, itemInput],
                    outputs: output
                });
                
                this.model.compile({
                    optimizer: tf.train.adam(parseFloat(document.getElementById('learningRate').value)),
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });
                
                this.log(`âœ… ëª¨ë¸ ìƒì„± ì™„ë£Œ: ${this.numUsers} ì‚¬ìš©ì, ${this.numItems} ì•„ì´í…œ, ${this.embSize}D ì„ë² ë”©`);
                this.log(`ğŸ“Š ì´ íŒŒë¼ë¯¸í„° ìˆ˜: ${this.model.countParams().toLocaleString()}`);
            }
            
            processCSVData() {
                this.log("ğŸ“Š CSV ë°ì´í„° ì²˜ë¦¬ ì¤‘...");
                
                const data = this.csvData;
                const numSamples = Math.min(data.length, parseInt(document.getElementById('numSamples').value));
                
                // ë°ì´í„° ì…”í”Œ ë° ìƒ˜í”Œë§
                const shuffled = data.sort(() => 0.5 - Math.random()).slice(0, numSamples);
                
                const users = shuffled.map(row => row.user);
                const items = shuffled.map(row => row.item);
                const labels = shuffled.map(row => row.label);
                
                // 80% í•™ìŠµ, 20% ê²€ì¦
                const splitIndex = Math.floor(numSamples * 0.8);
                
                const trainData = {
                    users: tf.tensor2d(users.slice(0, splitIndex).map(u => [u]), [users.slice(0, splitIndex).length, 1], 'int32'),
                    items: tf.tensor2d(items.slice(0, splitIndex).map(i => [i]), [items.slice(0, splitIndex).length, 1], 'int32'),
                    labels: tf.tensor2d(labels.slice(0, splitIndex).map(l => [l]))
                };
                
                const valData = {
                    users: tf.tensor2d(users.slice(splitIndex).map(u => [u]), [users.slice(splitIndex).length, 1], 'int32'),
                    items: tf.tensor2d(items.slice(splitIndex).map(i => [i]), [items.slice(splitIndex).length, 1], 'int32'),
                    labels: tf.tensor2d(labels.slice(splitIndex).map(l => [l]))
                };
                
                this.log(`âœ… CSV ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ: í•™ìŠµ ${trainData.users.shape[0]}ê°œ, ê²€ì¦ ${valData.users.shape[0]}ê°œ`);
                
                return { trainData, valData };
            }
            
            generateSyntheticData() {
                this.log("ğŸ“Š í•™ìŠµ ë°ì´í„° ìƒì„± ì¤‘...");
                
                const numSamples = parseInt(document.getElementById('numSamples').value);
                
                const users = [];
                const items = [];
                const labels = [];
                
                for (let i = 0; i < numSamples; i++) {
                    const user = Math.floor(Math.random() * this.numUsers);
                    const item = Math.floor(Math.random() * this.numItems);
                    
                    // ê°„ë‹¨í•œ íŒ¨í„´
                    const label = (user + item) % 2 === 0 ? 1 : 0;
                    const finalLabel = Math.random() < 0.1 ? 1 - label : label;
                    
                    users.push(user);
                    items.push(item);
                    labels.push(finalLabel);
                }
                
                const splitIndex = Math.floor(numSamples * 0.8);
                
                const trainData = {
                    users: tf.tensor2d(users.slice(0, splitIndex).map(u => [u]), [users.slice(0, splitIndex).length, 1], 'int32'),
                    items: tf.tensor2d(items.slice(0, splitIndex).map(i => [i]), [items.slice(0, splitIndex).length, 1], 'int32'),
                    labels: tf.tensor2d(labels.slice(0, splitIndex).map(l => [l]))
                };
                
                const valData = {
                    users: tf.tensor2d(users.slice(splitIndex).map(u => [u]), [users.slice(splitIndex).length, 1], 'int32'),
                    items: tf.tensor2d(items.slice(splitIndex).map(i => [i]), [items.slice(splitIndex).length, 1], 'int32'),
                    labels: tf.tensor2d(labels.slice(splitIndex).map(l => [l]))
                };
                
                this.log(`âœ… ë°ì´í„° ìƒì„± ì™„ë£Œ: í•™ìŠµ ${trainData.users.shape[0]}ê°œ, ê²€ì¦ ${valData.users.shape[0]}ê°œ`);
                
                return { trainData, valData };
            }
            
            generateData() {
                const dataSource = document.getElementById('dataSource').value;
                
                if (dataSource === 'csv' && this.csvData) {
                    this.log("ğŸ“Š CSV ë°ì´í„° ì‚¬ìš© ì¤‘...");
                    return this.processCSVData();
                } else {
                    this.log("ğŸ“Š ê°€ìƒ ë°ì´í„° ìƒì„± ì¤‘...");
                    return this.generateSyntheticData();
                }
            }
            
            async train() {
                if (this.isTraining) return;
                this.isTraining = true;
                
                try {
                    this.updateStatus("ğŸš€ í•™ìŠµ ì‹œì‘");
                    this.log("ğŸ¯ NCF ëª¨ë¸ í•™ìŠµì„ ì‹œì‘í•©ë‹ˆë‹¤...");
                    
                    this.createModel();
                    const { trainData, valData } = this.generateData();
                    const epochs = parseInt(document.getElementById('epochs').value);
                    
                    this.log(`ğŸ“š í•™ìŠµ ë°ì´í„°: ${trainData.users.shape[0]}ê°œ, ê²€ì¦ ë°ì´í„°: ${valData.users.shape[0]}ê°œ`);
                    this.log(`ğŸ”„ ì—í¬í¬ ìˆ˜: ${epochs}, ë°°ì¹˜ í¬ê¸°: 32`);
                    this.log("=" * 50);
                    
                    await this.model.fit(
                        [trainData.users, trainData.items],
                        trainData.labels,
                        {
                            epochs: epochs,
                            batchSize: 32,
                            validationData: [
                                [valData.users, valData.items],
                                valData.labels
                            ],
                            shuffle: true,
                            verbose: 1,
                            callbacks: {
                                onEpochBegin: (epoch) => {
                                    this.log(`\nğŸ”„ Epoch ${epoch + 1}/${epochs} ì‹œì‘...`);
                                },
                                onEpochEnd: (epoch, logs) => {
                                    const progress = ((epoch + 1) / epochs) * 100;
                                    this.updateProgress(progress);
                                    this.updateMetrics(
                                        epoch + 1,
                                        logs.loss || 0,
                                        logs.val_loss || 0,
                                        logs.val_accuracy || 0
                                    );
                                    
                                    // ìƒì„¸í•œ ë¡œê·¸ ì¶œë ¥
                                    const lossStr = (logs.loss || 0).toFixed(4);
                                    const valLossStr = (logs.val_loss || 0).toFixed(4);
                                    const valAccStr = (logs.val_accuracy || 0).toFixed(4);
                                    
                                    this.log(`âœ… Epoch ${epoch + 1}/${epochs} ì™„ë£Œ:`);
                                    this.log(`   ğŸ“‰ í•™ìŠµ ì†ì‹¤: ${lossStr}`);
                                    this.log(`   ğŸ“Š ê²€ì¦ ì†ì‹¤: ${valLossStr}`);
                                    this.log(`   ğŸ¯ ê²€ì¦ ì •í™•ë„: ${valAccStr}`);
                                    
                                    // ê³¼ì í•© ê²½ê³ 
                                    if (logs.val_loss > logs.loss * 2) {
                                        this.log(`   âš ï¸  ê³¼ì í•© ìœ„í—˜ ê°ì§€!`);
                                    }
                                    
                                    this.log("-" * 40);
                                },
                                onBatchEnd: (batch, logs) => {
                                    // 10ë²ˆì§¸ ë°°ì¹˜ë§ˆë‹¤ ì¤‘ê°„ ì§„í–‰ìƒí™© ì¶œë ¥
                                    if (batch % 10 === 0 && batch > 0) {
                                        this.log(`   ë°°ì¹˜ ${batch}: loss=${(logs.loss || 0).toFixed(4)}`);
                                    }
                                }
                            }
                        }
                    );
                    
                    // ë©”ëª¨ë¦¬ ì •ë¦¬
                    this.log("ğŸ§¹ ë©”ëª¨ë¦¬ ì •ë¦¬ ì¤‘...");
                    trainData.users.dispose();
                    trainData.items.dispose();
                    trainData.labels.dispose();
                    valData.users.dispose();
                    valData.items.dispose();
                    valData.labels.dispose();
                    
                    this.updateStatus("âœ… í•™ìŠµ ì™„ë£Œ!");
                    this.log("=" * 50);
                    this.log("ğŸ‰ NCF ëª¨ë¸ í•™ìŠµì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!");
                    this.log("ğŸ’¡ ì´ì œ ì˜ˆì¸¡ ë° ì¶”ì²œ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
                    this.log("=" * 50);
                    
                    document.getElementById('predict').disabled = false;
                    document.getElementById('analyzeWrongProblem').disabled = false;
                    document.getElementById('hybridRecommend').disabled = false;
                    
                } catch (error) {
                    this.log("ğŸ’¥ í•™ìŠµ ì¤‘ ì¹˜ëª…ì  ì—ëŸ¬ ë°œìƒ!");
                    this.log(`âŒ ì—ëŸ¬ ë©”ì‹œì§€: ${error.message}`);
                    this.log(`ğŸ“ ì—ëŸ¬ ìœ„ì¹˜: ${error.stack}`);
                    this.updateStatus("âŒ í•™ìŠµ ì‹¤íŒ¨");
                    console.error('Training error:', error);
                } finally {
                    this.isTraining = false;
                    document.getElementById('startTraining').disabled = false;
                    this.log("ğŸ”š í•™ìŠµ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ");
                }
            }
            
            async predict(userId, itemId) {
                if (!this.model) {
                    return "ëª¨ë¸ì´ í•™ìŠµë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.";
                }
                
                if (userId >= this.numUsers || itemId >= this.numItems) {
                    return "ì‚¬ìš©ì ID ë˜ëŠ” ì•„ì´í…œ IDê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤.";
                }
                
                try {
                    const userTensor = tf.tensor2d([[userId]], [1, 1], 'int32');
                    const itemTensor = tf.tensor2d([[itemId]], [1, 1], 'int32');
                    
                    const prediction = this.model.predict([userTensor, itemTensor]);
                    const score = await prediction.data();
                    
                    userTensor.dispose();
                    itemTensor.dispose();
                    prediction.dispose();
                    
                    const probability = score[0];
                    const recommendation = probability > 0.5 ? "ì •ë‹µ ì˜ˆìƒ" : "ì˜¤ë‹µ ì˜ˆìƒ";
                    
                    return `ì‚¬ìš©ì ${userId}ê°€ ë¬¸ì œ ${itemId}ë¥¼ í’€ ë•Œ: ${recommendation} (ì •ë‹µ í™•ë¥ : ${(probability * 100).toFixed(1)}%)`;
                    
                } catch (error) {
                    return `ì˜ˆì¸¡ ì¤‘ ì—ëŸ¬: ${error.message}`;
                }
            }
            
            async analyzeWrongProblem(studentId, wrongProblemId) {
                if (!this.model) {
                    return "ëª¨ë¸ì´ í•™ìŠµë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.";
                }
                
                this.log(`ğŸ” ë¶„ì„ ì‹œì‘: í•™ìƒ ${studentId}ê°€ ë¬¸ì œ ${wrongProblemId}ë¥¼ í‹€ë¦¼`);
                
                try {
                    // 1. í•´ë‹¹ í•™ìƒì˜ ì¼ë°˜ì ì¸ ì¶”ì²œ
                    this.log("1ï¸âƒ£ ì¼ë°˜ ì¶”ì²œ ë¶„ì„ ì¤‘...");
                    const generalRecs = await this.getDetailedRecommendations(studentId, 10);
                    
                    // 2. ì˜¤ë‹µ ê°€ëŠ¥ì„±ì´ ë†’ì€ ë¬¸ì œë“¤ ì°¾ê¸° (ì •ë‹µ í™•ë¥ ì´ ë‚®ì€ ê²ƒë“¤)
                    this.log("2ï¸âƒ£ ì˜¤ë‹µ ìœ„í—˜ ë¬¸ì œ ë¶„ì„ ì¤‘...");
                    const riskProblems = await this.getRiskProblems(studentId, 10);
                    
                    // 3. í‹€ë¦° ë¬¸ì œ ì£¼ë³€ ë²”ìœ„ì—ì„œ ì¶”ì²œ
                    this.log("3ï¸âƒ£ ê´€ë ¨ ë¬¸ì œ ë¶„ì„ ì¤‘...");
                    const relatedRecs = await this.getRelatedRecommendations(studentId, wrongProblemId, 5);
                    
                    let result = `ğŸ“Š <strong>í•™ìƒ ${studentId} ë¬¸ì œ ${wrongProblemId} í‹€ë¦¼ ë¶„ì„</strong><br><br>`;
                    
                    result += `<div style="background: rgba(0,255,0,0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">`;
                    result += `<strong>âœ… ì¶”ì²œ ë¬¸ì œ (ì •ë‹µ ê°€ëŠ¥ì„± ë†’ìŒ)</strong><br>`;
                    generalRecs.slice(0, 5).forEach((rec, i) => {
                        result += `${i+1}. ë¬¸ì œ ${rec.itemId} - ${(rec.score * 100).toFixed(1)}% ğŸ¯<br>`;
                    });
                    result += `</div>`;
                    
                    result += `<div style="background: rgba(255,0,0,0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">`;
                    result += `<strong>âš ï¸ ì£¼ì˜ ë¬¸ì œ (ì˜¤ë‹µ ìœ„í—˜ ë†’ìŒ)</strong><br>`;
                    riskProblems.slice(0, 5).forEach((rec, i) => {
                        result += `${i+1}. ë¬¸ì œ ${rec.itemId} - ${(rec.score * 100).toFixed(1)}% âš ï¸<br>`;
                    });
                    result += `</div>`;
                    
                    result += `<div style="background: rgba(0,0,255,0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">`;
                    result += `<strong>ğŸ”— ê´€ë ¨ ë¬¸ì œ (í‹€ë¦° ë¬¸ì œ ì£¼ë³€)</strong><br>`;
                    relatedRecs.forEach((rec, i) => {
                        result += `${i+1}. ë¬¸ì œ ${rec.itemId} - ${(rec.score * 100).toFixed(1)}% ğŸ”<br>`;
                    });
                    result += `</div>`;
                    
                    return result;
                    
                } catch (error) {
                    return `ë¶„ì„ ì¤‘ ì—ëŸ¬: ${error.message}`;
                }
            }
            
            async getDetailedRecommendations(userId, topK) {
                const scores = [];
                const startItem = Math.max(0, Math.floor(this.numItems * 0.3));
                const endItem = Math.min(this.numItems, startItem + 200);
                
                for (let itemId = startItem; itemId < endItem; itemId++) {
                    const userTensor = tf.tensor2d([[userId]], [1, 1], 'int32');
                    const itemTensor = tf.tensor2d([[itemId]], [1, 1], 'int32');
                    
                    const prediction = this.model.predict([userTensor, itemTensor]);
                    const score = await prediction.data();
                    
                    scores.push({ itemId: itemId, score: score[0] });
                    
                    userTensor.dispose();
                    itemTensor.dispose();
                    prediction.dispose();
                }
                
                return scores.sort((a, b) => b.score - a.score).slice(0, topK);
            }
            
            async getRiskProblems(userId, topK) {
                const scores = [];
                const startItem = Math.max(0, Math.floor(this.numItems * 0.3));
                const endItem = Math.min(this.numItems, startItem + 200);
                
                for (let itemId = startItem; itemId < endItem; itemId++) {
                    const userTensor = tf.tensor2d([[userId]], [1, 1], 'int32');
                    const itemTensor = tf.tensor2d([[itemId]], [1, 1], 'int32');
                    
                    const prediction = this.model.predict([userTensor, itemTensor]);
                    const score = await prediction.data();
                    
                    scores.push({ itemId: itemId, score: score[0] });
                    
                    userTensor.dispose();
                    itemTensor.dispose();
                    prediction.dispose();
                }
                
                // ì˜¤ë‹µ ìœ„í—˜ì´ ë†’ì€ ê²ƒë“¤ (ë‚®ì€ ì ìˆ˜ ìˆœ)
                return scores.sort((a, b) => a.score - b.score).slice(0, topK);
            }
            
            async getRelatedRecommendations(userId, wrongProblemId, topK) {
                const scores = [];
                const range = 100; // í‹€ë¦° ë¬¸ì œ Â±100 ë²”ìœ„
                const startItem = Math.max(0, wrongProblemId - range);
                const endItem = Math.min(this.numItems, wrongProblemId + range);
                
                for (let itemId = startItem; itemId < endItem; itemId++) {
                    if (itemId === wrongProblemId) continue; // í‹€ë¦° ë¬¸ì œ ì œì™¸
                    
                    const userTensor = tf.tensor2d([[userId]], [1, 1], 'int32');
                    const itemTensor = tf.tensor2d([[itemId]], [1, 1], 'int32');
                    
                    const prediction = this.model.predict([userTensor, itemTensor]);
                    const score = await prediction.data();
                    
                    scores.push({ itemId: itemId, score: score[0] });
                    
                    userTensor.dispose();
                    itemTensor.dispose();
                    prediction.dispose();
                }
                
                return scores.sort((a, b) => b.score - a.score).slice(0, topK);
            }
        }
        
        // ì „ì—­ ë³€ìˆ˜
        let ncfModel = null;
        
        function toggleDataSource() {
            const dataSource = document.getElementById('dataSource').value;
            const csvUpload = document.getElementById('csvUpload');
            
            if (dataSource === 'csv') {
                csvUpload.style.display = 'block';
            } else {
                csvUpload.style.display = 'none';
            }
        }
        
        function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('csvStatus').innerHTML = 'ğŸ“Š CSV íŒŒì¼ ì½ëŠ” ì¤‘...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csv = e.target.result;
                    const lines = csv.split('\n').filter(line => line.trim());
                    
                    const data = [];
                    const userSet = new Set();
                    const itemSet = new Set();
                    
                    lines.forEach((line) => {
                        const parts = line.split(',').map(s => s.trim());
                        
                        if (parts.length >= 3) {
                            const studentId = parts[0];
                            const problemId = parts[1];
                            const label = parts[2];
                            
                            if (!isNaN(studentId) && !isNaN(problemId) && !isNaN(label)) {
                                userSet.add(studentId);
                                itemSet.add(problemId);
                                
                                data.push({
                                    originalUser: studentId,
                                    originalItem: problemId,
                                    label: parseFloat(label)
                                });
                            }
                        }
                    });
                    
                    if (data.length === 0) {
                        throw new Error('ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    
                    // ì‚¬ìš©ì/ì•„ì´í…œ ë§¤í•‘
                    const users = Array.from(userSet).sort((a, b) => a - b);
                    const items = Array.from(itemSet).sort((a, b) => a - b);
                    
                    const userMap = {};
                    const itemMap = {};
                    
                    users.forEach((user, idx) => userMap[user] = idx);
                    items.forEach((item, idx) => itemMap[item] = idx);
                    
                    // ë°ì´í„° ë³€í™˜
                    const processedData = data.map(row => ({
                        user: userMap[row.originalUser],
                        item: itemMap[row.originalItem],
                        label: Math.max(0, Math.min(1, row.label))
                    }));
                    
                    // ì„¤ì • ì—…ë°ì´íŠ¸
                    document.getElementById('numUsers').value = users.length;
                    document.getElementById('numItems').value = items.length;
                    document.getElementById('numSamples').value = Math.min(processedData.length, 5000);
                    
                    // ì¡´ì¬í•˜ëŠ” ìš”ì†Œë§Œ ì—…ë°ì´íŠ¸
                    const testUserEl = document.getElementById('testUser');
                    const testItemEl = document.getElementById('testItem');
                    const wrongStudentEl = document.getElementById('wrongStudent');
                    
                    if (testUserEl) testUserEl.max = users.length - 1;
                    if (testItemEl) testItemEl.max = items.length - 1;
                    if (wrongStudentEl) wrongStudentEl.max = users.length - 1;
                    
                    // CSV ë°ì´í„° ì €ì¥
                    if (ncfModel) {
                        ncfModel.csvData = processedData;
                    }
                    
                    // ë°ì´í„° í†µê³„
                    const labelCounts = processedData.reduce((acc, row) => {
                        acc[row.label] = (acc[row.label] || 0) + 1;
                        return acc;
                    }, {});
                    
                    document.getElementById('csvStatus').innerHTML = 
                        `âœ… CSV ë¡œë“œ ì™„ë£Œ!<br>
                        ğŸ“Š ${processedData.length.toLocaleString()}ê°œ ë ˆì½”ë“œ<br>
                        ğŸ‘¥ ${users.length}ëª… ì‚¬ìš©ì<br>
                        ğŸ“š ${items.length}ê°œ ë¬¸ì œ<br>
                        âœ… ì •ë‹µ: ${(labelCounts[1] || 0).toLocaleString()}ê°œ<br>
                        âŒ ì˜¤ë‹µ: ${(labelCounts[0] || 0).toLocaleString()}ê°œ<br>
                        ğŸ“ˆ ì •ë‹µë¥ : ${((labelCounts[1] || 0) / processedData.length * 100).toFixed(1)}%`;
                    
                } catch (error) {
                    document.getElementById('csvStatus').innerHTML = 
                        `âŒ CSV íŒŒì‹± ì—ëŸ¬: ${error.message}`;
                    console.error('CSV parsing error:', error);
                }
            };
            
            reader.readAsText(file);
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('startTraining').addEventListener('click', async () => {
            console.log('ğŸ”¥ í•™ìŠµ ë²„íŠ¼ í´ë¦­ë¨!'); // ë””ë²„ê¹…ìš©
            
            const numUsers = parseInt(document.getElementById('numUsers').value);
            const numItems = parseInt(document.getElementById('numItems').value);
            const embSize = parseInt(document.getElementById('embSize').value);
            
            console.log(`ì„¤ì •ê°’ - ì‚¬ìš©ì: ${numUsers}, ì•„ì´í…œ: ${numItems}, ì„ë² ë”©: ${embSize}`);
            
            // ì¡´ì¬í•˜ëŠ” ìš”ì†Œë§Œ ì—…ë°ì´íŠ¸
            const testUserEl = document.getElementById('testUser');
            const testItemEl = document.getElementById('testItem');
            const wrongStudentEl = document.getElementById('wrongStudent');
            
            if (testUserEl) testUserEl.max = numUsers - 1;
            if (testItemEl) testItemEl.max = numItems - 1;
            if (wrongStudentEl) wrongStudentEl.max = numUsers - 1;
            
            // ì¦‰ì‹œ ë¡œê·¸ ì¶œë ¥ìœ¼ë¡œ ë°˜ì‘ í™•ì¸
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.textContent += `[${timestamp}] ğŸ”¥ í•™ìŠµ ë²„íŠ¼ì´ í´ë¦­ë˜ì—ˆìŠµë‹ˆë‹¤!\n`;
            logElement.scrollTop = logElement.scrollHeight;
            
            // NCF ëª¨ë¸ ìƒì„±
            try {
                ncfModel = new NCFModel(numUsers, numItems, embSize);
                
                const dataSource = document.getElementById('dataSource').value;
                if (dataSource === 'csv') {
                    const csvFile = document.getElementById('csvFile').files[0];
                    if (!csvFile) {
                        alert('CSV íŒŒì¼ì„ ë¨¼ì € ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                        return;
                    }
                    console.log('CSV ë°ì´í„° ì‚¬ìš© ì˜ˆì •');
                } else {
                    console.log('ê°€ìƒ ë°ì´í„° ì‚¬ìš© ì˜ˆì •');
                }
                
                document.getElementById('startTraining').disabled = true;
                document.getElementById('predict').disabled = true;
                document.getElementById('analyzeWrongProblem').disabled = true;
                document.getElementById('hybridRecommend').disabled = true;
                
                console.log('ëª¨ë¸ í•™ìŠµ ì‹œì‘...');
                await ncfModel.train();
                console.log('ëª¨ë¸ í•™ìŠµ ì™„ë£Œ!');
                
            } catch (error) {
                console.error('í•™ìŠµ ë²„íŠ¼ ì²˜ë¦¬ ì¤‘ ì—ëŸ¬:', error);
                const logElement = document.getElementById('log');
                const timestamp = new Date().toLocaleTimeString();
                logElement.textContent += `[${timestamp}] âŒ ë²„íŠ¼ ì²˜ë¦¬ ì—ëŸ¬: ${error.message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
                
                document.getElementById('startTraining').disabled = false;
            }
        });
        
        document.getElementById('predict').addEventListener('click', async () => {
            console.log('ğŸ”® ì˜ˆì¸¡ ë²„íŠ¼ í´ë¦­ë¨!');
            if (!ncfModel) {
                alert('ë¨¼ì € ëª¨ë¸ì„ í•™ìŠµì‹œì¼œì£¼ì„¸ìš”!');
                return;
            }
            
            const userId = parseInt(document.getElementById('testUser').value);
            const itemId = parseInt(document.getElementById('testItem').value);
            
            console.log(`ì˜ˆì¸¡ ìš”ì²­: ì‚¬ìš©ì ${userId}, ì•„ì´í…œ ${itemId}`);
            
            try {
                const result = await ncfModel.predict(userId, itemId);
                document.getElementById('predictionResult').textContent = result;
                console.log('ì˜ˆì¸¡ ì™„ë£Œ:', result);
            } catch (error) {
                console.error('ì˜ˆì¸¡ ì¤‘ ì—ëŸ¬:', error);
                document.getElementById('predictionResult').textContent = `ì˜ˆì¸¡ ì—ëŸ¬: ${error.message}`;
            }
        });
        
        // ìƒˆë¡œìš´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
        document.getElementById('analyzeWrongProblem').addEventListener('click', async () => {
            if (!ncfModel) {
                alert('ë¨¼ì € ëª¨ë¸ì„ í•™ìŠµì‹œì¼œì£¼ì„¸ìš”!');
                return;
            }
            
            const studentId = parseInt(document.getElementById('wrongStudent').value);
            const wrongProblemId = parseInt(document.getElementById('wrongProblem').value);
            
            document.getElementById('analysisResult').innerHTML = 'ğŸ” ë¶„ì„ ì¤‘...';
            
            const result = await ncfModel.analyzeWrongProblem(studentId, wrongProblemId);
            document.getElementById('analysisResult').innerHTML = result;
        });
        
        document.getElementById('hybridRecommend').addEventListener('click', async () => {
            if (!ncfModel) {
                alert('ë¨¼ì € ëª¨ë¸ì„ í•™ìŠµì‹œì¼œì£¼ì„¸ìš”!');
                return;
            }
            
            const ncfWeight = parseFloat(document.getElementById('ncfWeight').value);
            const freqWeight = 1.0 - ncfWeight;
            document.getElementById('freqWeight').value = freqWeight.toFixed(1);
            
            // ê°„ë‹¨í•œ í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ ì‹œë®¬ë ˆì´ì…˜
            const studentId = parseInt(document.getElementById('wrongStudent').value);
            
            document.getElementById('analysisResult').innerHTML = 'ğŸš€ í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ ê³„ì‚° ì¤‘...';
            
            const ncfRecs = await ncfModel.getDetailedRecommendations(studentId, 10);
            
            // ê°€ìƒì˜ ë¹ˆë„ ì ìˆ˜ (ì‹¤ì œë¡œëŠ” SQL ì¿¼ë¦¬ ê²°ê³¼ì™€ ê²°í•©)
            const hybridResults = ncfRecs.map(rec => {
                const mockFreqScore = Math.random() * 0.5 + 0.3; // 0.3-0.8 ì‚¬ì´ ê°€ìƒ ë¹ˆë„ ì ìˆ˜
                // ë¹ˆë„ ì ìˆ˜ë¥¼ ì •ë‹µë¥ ë¡œ ë³€í™˜ (ì˜¤ë‹µë¥  â†’ ì •ë‹µë¥ )
                const freqCorrectRate = 1.0 - mockFreqScore; // ì •ë‹µë¥ ë¡œ í†µì¼
                const hybridScore = ncfWeight * rec.score + freqWeight * freqCorrectRate;
                return {
                    itemId: rec.itemId,
                    ncfScore: rec.score,
                    freqScore: freqCorrectRate, // ì •ë‹µë¥ ë¡œ í‘œì‹œ
                    freqWrongRate: mockFreqScore, // ì›ë˜ ì˜¤ë‹µë¥ ë„ ë³´ê´€
                    hybridScore: hybridScore
                };
            });
            
            hybridResults.sort((a, b) => b.hybridScore - a.hybridScore);
            
            let result = `ğŸ¯ <strong>í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ ê²°ê³¼ (NCF:${ncfWeight} + ë¹ˆë„:${freqWeight})</strong><br><br>`;
            
            result += `<div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; margin-bottom: 15px;">`;
            result += `ğŸ“Š <strong>ì ìˆ˜ ì„¤ëª…:</strong><br>`;
            result += `â€¢ <strong>NCF ì •ë‹µë¥ </strong>: ì´ í•™ìƒì´ í•´ë‹¹ ë¬¸ì œë¥¼ ë§í í™•ë¥ <br>`;
            result += `â€¢ <strong>ë¹ˆë„ ì •ë‹µë¥ </strong>: ê°™ì€ ì•½ì ì„ ê°€ì§„ í•™ìƒë“¤ì˜ ì •ë‹µë¥ <br>`;
            result += `â€¢ <strong>ì¢…í•© ì ìˆ˜</strong>: ${(ncfWeight*100).toFixed(0)}% Ã— NCF + ${(freqWeight*100).toFixed(0)}% Ã— ë¹ˆë„<br>`;
            result += `</div>`;
            
            result += `<div style="background: rgba(128,0,128,0.1); padding: 10px; border-radius: 5px;">`;
            hybridResults.slice(0, 8).forEach((rec, i) => {
                const confidenceIcon = rec.hybridScore > 0.9 ? "ğŸ”¥" : rec.hybridScore > 0.8 ? "â­" : rec.hybridScore > 0.7 ? "ğŸ‘" : "ğŸ¤”";
                result += `${i+1}. ë¬¸ì œ ${rec.itemId} ${confidenceIcon}<br>`;
                result += `&nbsp;&nbsp;&nbsp;ğŸ“Š NCF ì •ë‹µë¥ : ${(rec.ncfScore * 100).toFixed(1)}% | `;
                result += `ğŸ“ˆ ë¹ˆë„ ì •ë‹µë¥ : ${(rec.freqScore * 100).toFixed(1)}% | `;
                result += `ğŸ¯ ì¢…í•©: ${(rec.hybridScore * 100).toFixed(1)}%<br>`;
                result += `&nbsp;&nbsp;&nbsp;<small>ğŸ’¡ ê°™ì€ ì•½ì  í•™ìƒë“¤ì˜ ì˜¤ë‹µë¥ : ${(rec.freqWrongRate * 100).toFixed(1)}%</small><br><br>`;
            });
            result += `</div>`;
            
            result += `<br>ğŸ’¡ <em>ë¹ˆë„ ì ìˆ˜ëŠ” ì‹œë®¬ë ˆì´ì…˜ ê°’ì…ë‹ˆë‹¤. ì‹¤ì œë¡œëŠ” SQL ì¿¼ë¦¬ ê²°ê³¼ì™€ ê²°í•©í•´ì•¼ í•©ë‹ˆë‹¤.</em>`;
            
            document.getElementById('analysisResult').innerHTML = result;
        });
        
        // NCF ê°€ì¤‘ì¹˜ ë³€ê²½ ì‹œ ë¹ˆë„ ê°€ì¤‘ì¹˜ ìë™ ì—…ë°ì´íŠ¸
        document.getElementById('ncfWeight').addEventListener('input', (e) => {
            const ncfWeight = parseFloat(e.target.value);
            const freqWeight = 1.0 - ncfWeight;
            document.getElementById('freqWeight').value = freqWeight.toFixed(1);
        });
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì¦‰ì‹œ ì‹¤í–‰ë˜ëŠ” ì´ˆê¸°í™”
        console.log('ğŸš€ NCF ë°ëª¨ í˜ì´ì§€ ë¡œë“œë¨');
        console.log('TensorFlow.js ë²„ì „:', tf.version);
        
        // ë²„íŠ¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        const startBtn = document.getElementById('startTraining');
        if (startBtn) {
            console.log('âœ… í•™ìŠµ ì‹œì‘ ë²„íŠ¼ ë°œê²¬');
        } else {
            console.error('âŒ í•™ìŠµ ì‹œì‘ ë²„íŠ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ');
        }
        
        // ì´ˆê¸° ìƒíƒœ
        document.getElementById('predict').disabled = true;
        document.getElementById('analyzeWrongProblem').disabled = true;
        document.getElementById('hybridRecommend').disabled = true;
        
        // TensorFlow.js ì •ë³´ ì¶œë ¥
        const logElement = document.getElementById('log');
        const timestamp = new Date().toLocaleTimeString();
        logElement.textContent += `[${timestamp}] ğŸš€ NCF ë°ëª¨ ì¤€ë¹„ ì™„ë£Œ (TF.js ${tf.version.tfjs})\n`;
        logElement.textContent += `[${timestamp}] ğŸ’¡ CSV íŒŒì¼ ì—…ë¡œë“œ ë˜ëŠ” ê°€ìƒ ë°ì´í„°ë¡œ í•™ìŠµì„ ì‹œì‘í•˜ì„¸ìš”\n`;
        logElement.scrollTop = logElement.scrollHeight;
    </script>
</body>
</html>
